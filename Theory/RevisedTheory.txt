Bull Stack Brain Storming

BullScript (Scripting Language)
    \/
Bull / Bull Lang (Compiled Language / Runtime / Compiler)
    \/
BASM (Bull Assembly)
    \/
NASM (NASM)

Let's build this from the bottom up.

NASM as a language has more features than needed and is not intuitive.
You need to memorize significant short hand instructions and registers.

ASM conceptually isn't difficult to learn, but no one writes it because it's awful to write.
Here we reach our first step: BASM.

BASM should be easy to learn, verbose when needed, and you shouldn't need to memorize weird registers or archaic syntax.
Some of the ideas I have are:
    -Instead of db, dw, dd, etc, use 8b, 16b, 32b, etc
        -This is easier to read and is a 1:1 mapping to your brain's idea of what the data is
    -Explicitly use words for instructions so reading is easier
        -This is a 1:1 mapping to your brain's idea of what the instruction is
        -mov -> move
        -sub -> subtract
        -int -> interrupt
        -jmp -> jump
    -When writing asm, you are either "creating" a value or "calling" a method
        -"create" for variables
        -"define" for methods
    -With these two keywords, all you have to do to make everything possible is to make "attributes"
    -Attributes are the way you would specify 8b, 16b, 32b, const, inline, args, etc

Note: Not final until test.basm is functional
A basic BASM program would look like:

    ; this is a comment
    ; newlines are the default delimiter
    ; line will end at semicolons
    ; multiple lines need the last char to be {

    create aValue : 8b, const = 5
    create aString : 8b = "Hello World!\n" ;should have built-in support for escape codes

    ; "required" means the function will be included even if not used
    ; "inline" means the function will be copied into the location it is called instead of being called
    define exit : required, inline {
        ; registers are reg0-reg15, with reg0 being the syscall register and reg1-reg5 being the syscall arguments
        move reg0, $exit ; $ is for syscall values
        move reg1, 0
        call ; call is "syscall" instruction also known as "interrupt"
    }

    ; "<-" is used to specify arguments
    ; '?' means the argument is optional
    ; the argument that is given when calling the function gets put into the register before the function is called
    define sysCall <- reg0, reg1?, reg2?, reg3?, reg4?, reg5? : required , inline {
        call
    }

    ; "output" is a specific register that is used for the return value
    ; the function will inline the output register into the location it is called
    ; functions that have output cannot be used as instructions
    define length <- reg0 : output {
        move output, reg0
        while (byte [output] != 0) {
            increment output
        }
        subtract output, reg0
        return; return must be called for non-inline functions
    }

    define while <- condition, contents : required, inline {
        label whileJump
        if condition {
            contents
            jump whileJump
        }
    }

    define print <- reg2 {
        sysCall $write, #stdout, reg2, (length reg2)
        ; # is for predetermined values
        ; () resolves sub-expressions with a return value

        return
    }

    define crash <- reg2 : inline {
        ; Starting the line with "multi" means it'll apply the instruction to each line of the container's contents
        ; Below this is equivallent to:
        ; move reg0, $exit
        ; move reg1, reg2
        multi move {
            reg0, $exit
            reg1, reg2
        }
        call
    }

    ; "condition" must be inside of parenthesis ie (reg0 > reg1)
    ; "contents" is the keyword to describe {}
    define if <- condition, contents : required, inline {
        ; "condition" is evaluated here
        jumpFalse ifEnd
        contents
        label ifEnd
    }


    ; "entry" is the function that is called when the program starts
    ; the program will fail to compile if "entry" or "exit" are not defined
    define entry {
        multi print {
            aValue ; print should be able to handle values and strings
            aString
            "Hello\n"
        }
        exit
    }



