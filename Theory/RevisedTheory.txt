Bull Stack Brain Storming

BullScript (Scripting Language)
    \/
Bull / Bull Lang (Compiled Language / Runtime / Compiler)
    \/
BASM (Bull Assembly)
    \/
NASM (NASM)

Let's build this from the bottom up.

NASM as a language has more features than needed and is not intuitive.
You need to memorize significant short hand instructions and registers.

ASM conceptually isn't difficult to learn, but no one writes it because it's awful to write.
Here we reach our first step: BASM.

BASM should be easy to learn, verbose when needed, and you shouldn't need to memorize weird registers or archaic syntax.
Some of the ideas I have are:
    -Instead of db, dw, dd, etc, use 8b, 16b, 32b, etc
        -This is easier to read and is a 1:1 mapping to your brain's idea of what the data is
    -Explicitly use words for instructions so reading is easier
        -This is a 1:1 mapping to your brain's idea of what the instruction is
        -mov -> move
        -sub -> subtract
        -int -> interrupt
        -jmp -> jump
    -When writing asm, you are either "creating" a value or "calling" a method
        -"create" for variables
        -"define" for methods
    -With these two keywords, all you have to do to make everything possible is to make "attributes"
    -Attributes are the way you would specify 8b, 16b, 32b, const, inline, args, etc

A basic BASM program would look like:

    ; this is a comment
    ; newlines are the default delimiter
    ; line will end at semicolons
    ; multiple lines need the last char to be {

    create aValue : 8b, const = 5
    create aString : 8b = "Hello World!\n" ;should have built-in support for escape codes

    define print <- 1 : required {
    ; "required" means the function will be included even if not used
        ; "<-" says how many args the function takes
        ; if not specified, it'll be assumed to be 0
        ; will compile error if not enough args given

        ; reg0-reg7 are the registers used for system calls
        ; will probably have other names for the registers as well
        ; multiple names can be used for the same register for readability depending on context
        ; this might change but I'll see if issues arise as the language develops
        ; regSys or reg0
        move regSys, $write
        move reg1, #stdout
        ; $ is for syscall values and # is for predetermined values
        ; this make it easier to read

        ; input1-input{x} are the arguments given to the function
        ; input0 I feel like should be something but I'm not sure what yet
        move reg2, input1
        move reg3, length input1
        ; length is a built-in function that returns a length of something looking for the first null terminated byte
        ; args are speperated by commas

        return; return cannot have values but there is "output" which is a register
    }

    define exit <- 0 : required, inline {
        move regSys, $exit
        move reg1, 0
        call ; call is "syscall" instruction
        ; you don't need "call" for functions because they are assumed called if they are used
    }

    define crash <- regB : inline {
        move regSys, $exit
        move reg1, regB
        call
    }

    ; "entry" is the function that is called when the program starts
    define entry <- 0 : required {
        print aValue ; print should be able to handle values and strings but not sure if what I have typed here works for that, I'll have to try when language is functional
        print aString
        print "Hello\n"
        exit
    }



