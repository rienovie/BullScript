
; db 8b / dw 16b / dd 32b / dq 64b
; when value set will go into .data
; when value not set will go into .bss
; const variables will go into .rodata
create const 8b message = "Hello World!\n"
; variables are assumed to vary in value unless specfied otherwise
; literals are assumed readOnly (will go into .rodata)

; can also do multiline create example:
create:
	8b anotherMessage = "Hello again!\n"
	8b aValue = 8 ; TODO: check print with 101 to see if working correctly
	16b unintializedVariable
	const 8b immutableMessage = "Immute Hello!\n"
end create

; define is a container to create a container
; define (new container keyword used to call) << (attributes)

; this is for basic Basm functions
define func :
	move tempInput input
	stackPush
	move input tempInput
	call regFunc
	move tempOutput output
	stackPop
	move output tempOutput
	return
end define

; All functions must return

; "condition" must be surrounded with parenthesis
; when "condition" is called inside a function, will assume condition input
; "&&" "||" with multiple comparisions will probably only be in BullScript not basm
; comparsions are ( = , != , < , > , <= , >= )

; inline means instead of creating a function will basically be copy-paste at the location it is called
; inline functions are container functions
; the contents keyword is required
; inline functions cannot return

fn if << inline:
	jumpCondition ifEnd
	contents
	label ifEnd
end fn

fn while << inline:
	label whileJump
	if condition :
		contents
		jump label whileJump
	end if
end fn

fn stackPush:
	pop reg1

	; This is equivallent to:
	; push sys
	; push arg1
	; ...
	push regA, regB, regC, regD, arg1, arg2, input, output

	push reg1

	return
end fn

fn stackPop:
	pop reg1

	; Called in reverse order to maintain correct values from stack
	pop output, input, arg2, arg1, regD, regC, regB, regA

	push reg1

	return
end fn

func length:
	move output input
	; conditions must be surrounded with parenthesis
	while (byte output != 0) :
		increment output
	end while
	subtract output input
	
	return
end func

func print:
	; two ways to call a syscall / each of these are equivallent
	; as this is typed, this'll be printed twice
	; $ is used to convert to value of syscall
	; # is used to convert to predetermined values

	; call style one:
	syscall $write, #stdout, input, length input

	; will print newline
	syscall $write, #stdout, "\n", 1

	; call style two:
	move sys $write
	move arg1 #stdout
	move arg2 input
	move arg3 length input
	; call by itself is assumed "syscall"
	call


	return
end func

; It'll be standard practice to use a "entry" & "exit" at the bottom of a file like this

fn exit:
	syscall $exit, 0
end fn

fn entry:
	print message
	print anotherMessage
	print aValue
	; print "A string literal\n"
	exit; exit will be called even if excluded at the end of the entry function
end fn
