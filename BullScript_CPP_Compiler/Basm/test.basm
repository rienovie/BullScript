
; db 8b / dw 16b / dd 32b / dq 64b
; when value set will go into .data
; when value not set will go into .bss
; const variables will go into .rodata
create const 8b message = "Hello World!\n"

; can also do multiline create example:
create:
	8b anotherMessage = "Hello again!\n"
	8b aValue = 8 ; TODO: check print with 101 to see if working correctly
	16b unintializedVariable
	const 8b immutableMessage = "Immute Hello!\n"
end create

; define is a container
; define (keyword to call) << contents (keyword)
; "contents" keyword is a "func" that takes muliple lines as an input
; after container defined, the text following with a : afterwards is how you would call it
; this allows pre & post actions to a function call
; I think this'll allow other things as well but will have to experiment
; These two defines "func" & "fn" will be built-in for Basm and BullScript

; this is for basic Basm functions
define func << contents :
	tempInput input
	stackPush
	input tempInput
	contents
	tempOutput output
	stackPop
	output tempOutput
end define

; this is a raw Basm function
define fn << contents :
	contents
end define

; All functions must return

func while << condition contents :
	label whileJump
	if condition :
		contents
		jump label whileJump
	end if

	return
end func

fn stackPush:
	; not sure on this name, but it's for rbx
	; I think I'll probably have multiple aliases for the same regs
	; ie rax(regA, sys)
	; I don't want the actual names to be used because I want this to be universal asm
	pop regB

	; This is equivallent to:
	; push sys
	; push arg1
	; ...
	push sys, arg1, arg2, arg3, arg4, arg5, arg6, input, output

	push regB

	return
end fn

fn stackPop:
	pop regB

	; Called in reverse order to maintain correct values from stack
	pop output, input, arg6, arg5, arg4, arg3, arg2, arg1, sys

	push regB

	return
end fn

func length:
	output input
	; conditions must be surrounded with parenthesis
	while (byte output != 0) :
		increment output
	end while
	output subtract input
	
	return
end func

func print:
	; two ways to call a syscall / each of these are equivallent
	; as this is typed, this'll be printed twice
	; $ is used to convert to value of syscall
	; # is used to convert to predetermined values

	; call style one:
	syscall $write, #stdout, input, length input

	; call style two:
	sys $write
	arg1 #stdout
	arg2 input
	arg3 length input
	call

	; TODO add a default \n to each print

	return
end func

; It'll be standard practice to use a "entry" & "exit" at the bottom of a file like this

fn exit:
	syscall $exit, 0
end fn

fn entry:
	print message
	print anotherMessage
	print aValue
	print "A string literal\n"
	exit
end fn
