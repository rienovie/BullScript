; Some basics
; <- used for comments

; values are decimal assumed
; binary 0b prefix
; hex 0x prefix
; float e(x) suffix

; variables are assumed to vary in value unless specfied otherwise
; This assumption will carry to bullscript
; Bullscript will have an enforce option that requires "mutable" for non-const variables but this will not be the default

; when value set will go into .data
; when value not set will go into .bss
; const variables will go into .rodata
; you must specify the size to allocate with uninitialized variables
; Instead of using db, dw, etc uses:
; 8b (db) / 16b (dw) / 32b (dd) / 64b (dq)


create const 8b message = "Hello World!\n"

; can also do a block create
create:
	8b anotherMessage = "Hello again!\n"
	8b aValue = 8
	16 16b unintializedVariable ; order for 16 or 16b doesn't matter as long as they're before the name
	const 8b immutableMessage = "Immute Hello!\n"
end create

; define is used to create functions or inlines
; "inline" means instead of creating a function will basically be copy-paste at the location it is called
; inlines are containers so the contents keyword is required
; All functions must return but inlines cannot return

; define (keyword used to call) << (attributes)
; right now there's only the inline attribute but will probably add more later or just change the syntax to remove the <<

; this is for basic bullscript functions
define func:
	move tempInput, input
	stackPush
	move input, tempInput
	call regFunc
	move tempOutput, output
	stackPop
	move output, tempOutput
	return
end define

define if << inline:
	jumpCondition ifEnd
	contents
	label ifEnd
end define

; "condition" must be surrounded with parenthesis
; when "condition" is called inside a function, will assume condition input
; "&&" "||" with multiple comparisions will probably only be in BullScript not basm
; comparsions are ( = , != , < , > , <= , >= )

define while << inline:
	label whileJump
	if condition :
		contents
		jump whileJump
	end if
end define

fn stackPush:
	pop reg1

	; Starting the line with "multi" means it'll apply the first item to each
	; on multilines use () to pass multiple values to each line
	; Below this is equivallent to:
	; push sys
	; push arg1
	; ...
	multi push regA, regB, regC, regD, arg1, arg2, input, output

	push reg1

	return
end fn

fn stackPop:
	pop reg1

	; Called in reverse order to maintain correct values from stack
	multi pop output, input, arg2, arg1, regD, regC, regB, regA

	push reg1

	return
end fn

func length:
	move output, input
	; conditions must be surrounded with parenthesis
	while (byte output != 0) :
		increment output
	end while
	subtract output, input
	
	return
end func

func print:
	; three ways to call a syscall / each of these are equivallent
	; as this is typed, this'll be printed three times
	; $ is used to convert to value of syscall
	; # is used to convert to predetermined values

	; call style one:
	syscall $write, #stdout, input, length input

	; will print newline
	syscall $write, #stdout, "\n", 1

	; call style two:
	move sys, $write
	move arg1, #stdout
	move arg2, input
	move arg3, length input
	; call by itself is assumed "syscall"
	call

	syscall $write, #stdout, "\n", 1

	; call style three:
	multi move (sys, $write), (arg1, #stdout), (arg2, input), (arg3, length input)
	call


	return
end func

; It'll be standard practice to use a "entry" & "exit" at the bottom of a file like this

fn exit:
	syscall $exit, 0
end fn

fn entry:
	multi print message, anotherMessage, aValue, "A string literal\n"
	exit; exit will be called even if excluded at the end of the entry function
end fn
