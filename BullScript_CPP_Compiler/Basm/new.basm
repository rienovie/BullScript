; this file is a technical example and not inteneded to teach basm
; you can learn from this, but I will rewrite a learning file later
; this is intented as an aid while writing the parser
; I will have two files later, one to teach the parser and another to teach the language
; This file should compile and run without errors


; this is a comment
; newlines are the default delimiter
; line will end at semicolons
; multiple lines need the last char to be {

create aValue : 8b, const = 5
create aString : 8b = "Hello World!\n" ;should have built-in support for escape codes

; this would be the same as above
create {
; cannot include '{' in a create line value
; parser currently looks to see if line contains '{' to determine if multiline create
; parser doesn't look for value in the rest of the initial line when multiline
	; parser should ignore the create keyword under multiline create
	; this is here to test the parser
    create aValue : 8b, const = 5
    aString : 8b = "Hello World!\n"
	; if multiple definitions, will just replace the previous definition
} ; when using {} the closing } must be on its own line
; the opening { must be on the initial line
; BASM will be particular in its syntax, but BullLang will be more flexible

; "required" means the function will be included even if not used
; "inline" means the function will be copied into the location it is called instead of being called
define exit : required, inline {
    ; registers are reg0-reg15, with reg0 being the syscall register and reg1-reg5 being the syscall arguments
    move reg0, $exit ; $ is for syscall values
    move reg1, 0
    call ; call is "syscall" instruction also known as "interrupt"
}

; "()" is used to specify arguments
; '?' means the argument is optional
; the argument that is given when calling the function gets put into the register before the function is called
define sysCall(reg0, reg1?, reg2?, reg3?, reg4?, reg5?) : required , inline {
    call
}

; if a register is specified as an attribute, it will inline the register into the location it is called
; functions that specify a return register cannot be used as instructions (ie: first line item)
define length(reg0) : reg1 {
    move reg1, reg0
    while (byte [reg1] != 0) {
        increment reg1
    }
    subtract reg1, reg0
    return; return must be called for non-inline functions
}

define while(condition, contents) : required, inline {
    ; labels inside an inline function will become unique each time the function is called
    ; will become something like:
    ; label whileJump_0
    ; label whileJump_1
    ; ...
    label whileJump
    if condition {
        contents
	; jumps must be scoped to a function so should give compiler error if attempted jump outside of function
        jump whileJump
    }
}

define print(reg2) {
    sysCall $write, #stdout, reg2, length(reg2)
    ; # is for predetermined values
    return
}

define printLine(reg2) {
	multi print {
		reg2
		#newline
	}
	return
}

define crash(reg2) : inline {
    ; Starting the line with "multi" means it'll apply the instruction to each line of the container's contents
    ; Below this is equivallent to:
    ; move reg0, $exit
    ; move reg1, reg2
    multi move {
        reg0, $exit
        reg1, reg2
    }
    call
}

; "contents" is the keyword to describe {}
define if(condition, contents) : required, inline {
    ; "evaluate" translates conditional expressions into comparison expressions
    evaluate condition
    jumpFalse ifEnd
    contents
    label ifEnd
}


; "entry" is the function that is called when the program starts
; the program will fail to compile if "entry" or "exit" are not defined
define entry {
    ; this value 
    create aSubCreate : 8b = "This is a sub create"

    multi printLine {
        aValue ; print should be able to handle values and strings
        aString
        "Hello\n"
		aSubCreate
    }
    exit
}

